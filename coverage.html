
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>attributes: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">abac_go_example/attributes/resolver.go (86.6%)</option>
				
				<option value="file1">abac_go_example/audit/logger.go (91.8%)</option>
				
				<option value="file2">abac_go_example/evaluator/pdp.go (88.6%)</option>
				
				<option value="file3">abac_go_example/main.go (0.0%)</option>
				
				<option value="file4">abac_go_example/operators/operators.go (88.3%)</option>
				
				<option value="file5">abac_go_example/storage/mock_storage.go (87.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package attributes

import (
        "fmt"
        "reflect"
        "strings"
        "time"

        "abac_go_example/models"
        "abac_go_example/storage"
)

// AttributeResolver handles attribute resolution and context enrichment
type AttributeResolver struct {
        storage storage.Storage
}

// NewAttributeResolver creates a new attribute resolver
func NewAttributeResolver(storage storage.Storage) *AttributeResolver <span class="cov8" title="1">{
        return &amp;AttributeResolver{
                storage: storage,
        }
}</span>

// EnrichContext enriches the evaluation context with all necessary attributes
func (r *AttributeResolver) EnrichContext(request *models.EvaluationRequest) (*models.EvaluationContext, error) <span class="cov8" title="1">{
        // Get subject
        subject, err := r.storage.GetSubject(request.SubjectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get subject: %w", err)
        }</span>

        // Get resource
        <span class="cov8" title="1">resource, err := r.storage.GetResource(request.ResourceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get resource: %w", err)
        }</span>

        // Get action
        <span class="cov8" title="1">action, err := r.storage.GetAction(request.Action)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get action: %w", err)
        }</span>

        // Enrich environment context
        <span class="cov8" title="1">environment := r.enrichEnvironmentContext(request.Context)

        // Resolve dynamic attributes
        r.resolveDynamicAttributes(subject, environment)

        return &amp;models.EvaluationContext{
                Subject:     subject,
                Resource:    resource,
                Action:      action,
                Environment: environment,
                Timestamp:   time.Now(),
        }, nil</span>
}

// enrichEnvironmentContext adds computed environment attributes
func (r *AttributeResolver) enrichEnvironmentContext(context map[string]interface{}) map[string]interface{} <span class="cov8" title="1">{
        enriched := make(map[string]interface{})

        // Copy existing context
        for k, v := range context </span><span class="cov8" title="1">{
                enriched[k] = v
        }</span>

        // Add current timestamp if not present
        <span class="cov8" title="1">if _, exists := enriched["timestamp"]; !exists </span><span class="cov0" title="0">{
                enriched["timestamp"] = time.Now().Format(time.RFC3339)
        }</span>

        // Extract time_of_day from timestamp
        <span class="cov8" title="1">if timestampStr, ok := enriched["timestamp"].(string); ok </span><span class="cov8" title="1">{
                if t, err := time.Parse(time.RFC3339, timestampStr); err == nil </span><span class="cov8" title="1">{
                        enriched["time_of_day"] = t.Format("15:04")
                        enriched["day_of_week"] = strings.ToLower(t.Weekday().String())
                        enriched["hour"] = t.Hour()
                        enriched["is_business_hours"] = r.isBusinessHours(t)
                }</span>
        }

        // Add derived IP attributes
        <span class="cov8" title="1">if sourceIP, ok := enriched["source_ip"].(string); ok </span><span class="cov8" title="1">{
                enriched["is_internal_ip"] = r.isInternalIP(sourceIP)
                enriched["ip_subnet"] = r.getIPSubnet(sourceIP)
        }</span>

        <span class="cov8" title="1">return enriched</span>
}

// resolveDynamicAttributes computes dynamic subject attributes
func (r *AttributeResolver) resolveDynamicAttributes(subject *models.Subject, environment map[string]interface{}) <span class="cov8" title="1">{
        if subject.Attributes == nil </span><span class="cov0" title="0">{
                subject.Attributes = make(map[string]interface{})
        }</span>

        // Calculate years_of_service if hire_date is available
        <span class="cov8" title="1">if hireDateStr, ok := subject.Attributes["hire_date"].(string); ok </span><span class="cov8" title="1">{
                if hireDate, err := time.Parse("2006-01-02", hireDateStr); err == nil </span><span class="cov8" title="1">{
                        years := time.Since(hireDate).Hours() / (24 * 365.25)
                        subject.Attributes["years_of_service"] = int(years)
                }</span>
        }

        // Add computed attributes based on current time
        <span class="cov8" title="1">now := time.Now()
        subject.Attributes["current_hour"] = now.Hour()
        subject.Attributes["current_day"] = strings.ToLower(now.Weekday().String())</span>
}

// GetAttributeValue retrieves a nested attribute value using dot notation
func (r *AttributeResolver) GetAttributeValue(target interface{}, path string) interface{} <span class="cov8" title="1">{
        if target == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">parts := strings.Split(path, ".")
        current := target

        for _, part := range parts </span><span class="cov8" title="1">{
                current = r.getFieldValue(current, part)
                if current == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return current</span>
}

// getFieldValue gets a field value from an object
func (r *AttributeResolver) getFieldValue(obj interface{}, field string) interface{} <span class="cov8" title="1">{
        if obj == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Handle map access
        <span class="cov8" title="1">if m, ok := obj.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                return m[field]
        }</span>

        // Handle struct access using reflection
        <span class="cov8" title="1">v := reflect.ValueOf(obj)
        if v.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                v = v.Elem()
        }</span>

        <span class="cov8" title="1">if v.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Try to find field by name (case-insensitive)
        <span class="cov8" title="1">t := v.Type()
        for i := 0; i &lt; v.NumField(); i++ </span><span class="cov8" title="1">{
                fieldType := t.Field(i)
                fieldName := fieldType.Name

                // Check JSON tag
                if jsonTag := fieldType.Tag.Get("json"); jsonTag != "" </span><span class="cov8" title="1">{
                        tagName := strings.Split(jsonTag, ",")[0]
                        if tagName == field </span><span class="cov8" title="1">{
                                fieldName = fieldType.Name
                        }</span>
                }

                <span class="cov8" title="1">if strings.EqualFold(fieldName, field) || strings.EqualFold(fieldType.Name, field) </span><span class="cov8" title="1">{
                        fieldValue := v.Field(i)
                        if fieldValue.CanInterface() </span><span class="cov8" title="1">{
                                return fieldValue.Interface()
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// ResolveHierarchy resolves hierarchical resource paths
func (r *AttributeResolver) ResolveHierarchy(resourcePath string) []string <span class="cov8" title="1">{
        if resourcePath == "" </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov8" title="1">parts := strings.Split(strings.Trim(resourcePath, "/"), "/")
        hierarchy := make([]string, 0, len(parts))

        current := ""
        for _, part := range parts </span><span class="cov8" title="1">{
                if part == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">current += "/" + part
                hierarchy = append(hierarchy, current)</span>
        }

        // Add wildcard patterns
        <span class="cov8" title="1">wildcardHierarchy := make([]string, 0, len(hierarchy)*2)
        for _, path := range hierarchy </span><span class="cov8" title="1">{
                wildcardHierarchy = append(wildcardHierarchy, path)
                wildcardHierarchy = append(wildcardHierarchy, path+"/*")
        }</span>

        <span class="cov8" title="1">return wildcardHierarchy</span>
}

// Helper functions

func (r *AttributeResolver) isBusinessHours(t time.Time) bool <span class="cov8" title="1">{
        hour := t.Hour()
        weekday := t.Weekday()

        // Business hours: 8 AM to 6 PM, Monday to Friday
        return weekday &gt;= time.Monday &amp;&amp; weekday &lt;= time.Friday &amp;&amp; hour &gt;= 8 &amp;&amp; hour &lt; 18
}</span>

func (r *AttributeResolver) isInternalIP(ip string) bool <span class="cov8" title="1">{
        // Check for private IP ranges
        return strings.HasPrefix(ip, "10.") ||
                strings.HasPrefix(ip, "192.168.") ||
                strings.HasPrefix(ip, "172.16.") ||
                ip == "127.0.0.1" ||
                ip == "localhost"
}</span>

func (r *AttributeResolver) getIPSubnet(ip string) string <span class="cov8" title="1">{
        parts := strings.Split(ip, ".")
        if len(parts) &gt;= 3 </span><span class="cov8" title="1">{
                return strings.Join(parts[:3], ".") + ".0/24"
        }</span>
        <span class="cov8" title="1">return ip</span>
}

// MatchResourcePattern checks if a resource matches a pattern (supports wildcards)
func (r *AttributeResolver) MatchResourcePattern(pattern, resource string) bool <span class="cov8" title="1">{
        if pattern == "*" </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if pattern == resource </span><span class="cov8" title="1">{
                return true
        }</span>

        // Handle wildcard patterns
        <span class="cov8" title="1">if strings.Contains(pattern, "*") </span><span class="cov8" title="1">{
                // Convert wildcard pattern to regex
                regexPattern := strings.ReplaceAll(pattern, "*", ".*")
                regexPattern = "^" + regexPattern + "$"

                // Simple regex matching (could be improved with proper regex library)
                return r.simpleWildcardMatch(pattern, resource)
        }</span>

        <span class="cov0" title="0">return false</span>
}

func (r *AttributeResolver) simpleWildcardMatch(pattern, str string) bool <span class="cov8" title="1">{
        // Simple wildcard matching implementation
        if pattern == "*" </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if !strings.Contains(pattern, "*") </span><span class="cov0" title="0">{
                return pattern == str
        }</span>

        // Split by * and check each part
        <span class="cov8" title="1">parts := strings.Split(pattern, "*")
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if string starts with first part
        <span class="cov8" title="1">if parts[0] != "" &amp;&amp; !strings.HasPrefix(str, parts[0]) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if string ends with last part
        <span class="cov8" title="1">if parts[len(parts)-1] != "" &amp;&amp; !strings.HasSuffix(str, parts[len(parts)-1]) </span><span class="cov8" title="1">{
                return false
        }</span>

        // For more complex patterns, we'd need proper regex
        // This is a simplified implementation
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package audit

import (
        "encoding/json"
        "fmt"
        "log"
        "os"
        "time"

        "abac_go_example/models"
)

// AuditLogger handles audit logging for policy evaluations
type AuditLogger struct {
        logFile *os.File
        logger  *log.Logger
}

// NewAuditLogger creates a new audit logger
func NewAuditLogger(logFilePath string) (*AuditLogger, error) <span class="cov8" title="1">{
        var logFile *os.File
        var err error

        if logFilePath != "" </span><span class="cov8" title="1">{
                logFile, err = os.OpenFile(logFilePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to open log file: %w", err)
                }</span>
        } else<span class="cov8" title="1"> {
                logFile = os.Stdout
        }</span>

        <span class="cov8" title="1">logger := log.New(logFile, "", 0) // No default timestamp, we'll add our own

        return &amp;AuditLogger{
                logFile: logFile,
                logger:  logger,
        }, nil</span>
}

// LogEvaluation logs a policy evaluation result
func (a *AuditLogger) LogEvaluation(request *models.EvaluationRequest, decision *models.Decision, context *models.EvaluationContext) error <span class="cov8" title="1">{
        auditContext := map[string]interface{}{
                "matched_policies": decision.MatchedPolicies,
                "reason":           decision.Reason,
        }

        // Safely add environment context
        if context.Environment != nil </span><span class="cov8" title="1">{
                if sourceIP, ok := context.Environment["source_ip"]; ok </span><span class="cov8" title="1">{
                        auditContext["source_ip"] = sourceIP
                }</span>
                <span class="cov8" title="1">if userAgent, ok := context.Environment["user_agent"]; ok </span><span class="cov0" title="0">{
                        auditContext["user_agent"] = userAgent
                }</span>
                <span class="cov8" title="1">if timestamp, ok := context.Environment["timestamp"]; ok </span><span class="cov8" title="1">{
                        auditContext["timestamp"] = timestamp
                }</span>
        }

        // Safely add subject context
        <span class="cov8" title="1">if context.Subject != nil </span><span class="cov8" title="1">{
                auditContext["subject_type"] = context.Subject.SubjectType
        }</span>

        // Safely add resource context
        <span class="cov8" title="1">if context.Resource != nil </span><span class="cov8" title="1">{
                auditContext["resource_type"] = context.Resource.ResourceType
        }</span>

        // Safely add action context
        <span class="cov8" title="1">if context.Action != nil </span><span class="cov8" title="1">{
                auditContext["action_category"] = context.Action.ActionCategory
        }</span>

        <span class="cov8" title="1">auditEntry := models.AuditLog{
                RequestID:    request.RequestID,
                SubjectID:    request.SubjectID,
                ResourceID:   request.ResourceID,
                ActionID:     request.Action,
                Decision:     decision.Result,
                EvaluationMs: decision.EvaluationTimeMs,
                CreatedAt:    time.Now(),
                Context:      auditContext,
        }

        return a.logEntry(auditEntry)</span>
}

// LogAccessAttempt logs an access attempt with additional context
func (a *AuditLogger) LogAccessAttempt(request *models.EvaluationRequest, decision *models.Decision, additionalContext map[string]interface{}) error <span class="cov8" title="1">{
        auditEntry := models.AuditLog{
                RequestID:    request.RequestID,
                SubjectID:    request.SubjectID,
                ResourceID:   request.ResourceID,
                ActionID:     request.Action,
                Decision:     decision.Result,
                EvaluationMs: decision.EvaluationTimeMs,
                CreatedAt:    time.Now(),
                Context:      make(map[string]interface{}),
        }

        // Copy request context
        for k, v := range request.Context </span><span class="cov8" title="1">{
                auditEntry.Context[k] = v
        }</span>

        // Add decision context
        <span class="cov8" title="1">auditEntry.Context["matched_policies"] = decision.MatchedPolicies
        auditEntry.Context["reason"] = decision.Reason

        // Add additional context
        for k, v := range additionalContext </span><span class="cov8" title="1">{
                auditEntry.Context[k] = v
        }</span>

        <span class="cov8" title="1">return a.logEntry(auditEntry)</span>
}

// LogSecurityEvent logs security-related events
func (a *AuditLogger) LogSecurityEvent(eventType string, subjectID string, details map[string]interface{}) error <span class="cov8" title="1">{
        auditEntry := models.AuditLog{
                RequestID: fmt.Sprintf("security-%d", time.Now().UnixNano()),
                SubjectID: subjectID,
                Decision:  eventType,
                CreatedAt: time.Now(),
                Context: map[string]interface{}{
                        "event_type": eventType,
                        "details":    details,
                },
        }

        return a.logEntry(auditEntry)
}</span>

// LogPolicyChange logs policy configuration changes
func (a *AuditLogger) LogPolicyChange(changeType string, policyID string, changedBy string, changes map[string]interface{}) error <span class="cov8" title="1">{
        auditEntry := models.AuditLog{
                RequestID:  fmt.Sprintf("policy-change-%d", time.Now().UnixNano()),
                SubjectID:  changedBy,
                ResourceID: policyID,
                Decision:   changeType,
                CreatedAt:  time.Now(),
                Context: map[string]interface{}{
                        "change_type": changeType,
                        "changes":     changes,
                        "changed_by":  changedBy,
                },
        }

        return a.logEntry(auditEntry)
}</span>

// logEntry writes an audit entry to the log
func (a *AuditLogger) logEntry(entry models.AuditLog) error <span class="cov8" title="1">{
        // Convert to JSON
        jsonData, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal audit entry: %w", err)
        }</span>

        // Log the JSON entry
        <span class="cov8" title="1">a.logger.Println(string(jsonData))

        return nil</span>
}

// GetAuditTrail retrieves audit trail for a specific subject or resource
func (a *AuditLogger) GetAuditTrail(subjectID, resourceID string, limit int) ([]*models.AuditLog, error) <span class="cov0" title="0">{
        // In a real implementation, this would query a database
        // For this mock implementation, we'll return empty results
        // as we're only writing to log files
        return []*models.AuditLog{}, nil
}</span>

// Close closes the audit logger and any open files
func (a *AuditLogger) Close() error <span class="cov8" title="1">{
        if a.logFile != nil &amp;&amp; a.logFile != os.Stdout </span><span class="cov8" title="1">{
                return a.logFile.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// AuditStats represents audit statistics
type AuditStats struct {
        TotalEvaluations int            `json:"total_evaluations"`
        PermitCount      int            `json:"permit_count"`
        DenyCount        int            `json:"deny_count"`
        NotApplicable    int            `json:"not_applicable"`
        AvgEvaluationMs  float64        `json:"avg_evaluation_ms"`
        TopPolicies      map[string]int `json:"top_policies"`
        TopSubjects      map[string]int `json:"top_subjects"`
        TopResources     map[string]int `json:"top_resources"`
        SecurityEvents   int            `json:"security_events"`
        PolicyChanges    int            `json:"policy_changes"`
}

// GetStats returns audit statistics (mock implementation)
func (a *AuditLogger) GetStats(since time.Time) (*AuditStats, error) <span class="cov8" title="1">{
        // In a real implementation, this would analyze log data
        // For this mock, return empty stats
        return &amp;AuditStats{
                TotalEvaluations: 0,
                PermitCount:      0,
                DenyCount:        0,
                NotApplicable:    0,
                AvgEvaluationMs:  0.0,
                TopPolicies:      make(map[string]int),
                TopSubjects:      make(map[string]int),
                TopResources:     make(map[string]int),
                SecurityEvents:   0,
                PolicyChanges:    0,
        }, nil
}</span>

// ComplianceReport generates a compliance report
type ComplianceReport struct {
        Period           string            `json:"period"`
        TotalAccesses    int               `json:"total_accesses"`
        SuccessfulAccess int               `json:"successful_access"`
        DeniedAccess     int               `json:"denied_access"`
        PolicyViolations []PolicyViolation `json:"policy_violations"`
        UnusualActivity  []UnusualActivity `json:"unusual_activity"`
        GeneratedAt      time.Time         `json:"generated_at"`
}

type PolicyViolation struct {
        SubjectID   string    `json:"subject_id"`
        ResourceID  string    `json:"resource_id"`
        Action      string    `json:"action"`
        PolicyID    string    `json:"policy_id"`
        Timestamp   time.Time `json:"timestamp"`
        Severity    string    `json:"severity"`
        Description string    `json:"description"`
}

type UnusualActivity struct {
        SubjectID    string                 `json:"subject_id"`
        ActivityType string                 `json:"activity_type"`
        Count        int                    `json:"count"`
        Details      map[string]interface{} `json:"details"`
        FirstSeen    time.Time              `json:"first_seen"`
        LastSeen     time.Time              `json:"last_seen"`
}

// GenerateComplianceReport generates a compliance report for a given period
func (a *AuditLogger) GenerateComplianceReport(since, until time.Time) (*ComplianceReport, error) <span class="cov8" title="1">{
        // Mock implementation - in reality would analyze audit logs
        report := &amp;ComplianceReport{
                Period:           fmt.Sprintf("%s to %s", since.Format("2006-01-02"), until.Format("2006-01-02")),
                TotalAccesses:    0,
                SuccessfulAccess: 0,
                DeniedAccess:     0,
                PolicyViolations: []PolicyViolation{},
                UnusualActivity:  []UnusualActivity{},
                GeneratedAt:      time.Now(),
        }

        return report, nil
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package evaluator

import (
        "fmt"
        "sort"
        "time"

        "abac_go_example/attributes"
        "abac_go_example/models"
        "abac_go_example/operators"
        "abac_go_example/storage"
)

// PolicyDecisionPoint (PDP) is the main evaluation engine
type PolicyDecisionPoint struct {
        storage           storage.Storage
        attributeResolver *attributes.AttributeResolver
        operatorRegistry  *operators.OperatorRegistry
}

// NewPolicyDecisionPoint creates a new PDP instance
func NewPolicyDecisionPoint(storage storage.Storage) *PolicyDecisionPoint <span class="cov8" title="1">{
        return &amp;PolicyDecisionPoint{
                storage:           storage,
                attributeResolver: attributes.NewAttributeResolver(storage),
                operatorRegistry:  operators.NewOperatorRegistry(),
        }
}</span>

// Evaluate performs policy evaluation for a given request
func (pdp *PolicyDecisionPoint) Evaluate(request *models.EvaluationRequest) (*models.Decision, error) <span class="cov8" title="1">{
        startTime := time.Now()

        // Step 1: Enrich context with all necessary attributes
        context, err := pdp.attributeResolver.EnrichContext(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to enrich context: %w", err)
        }</span>

        // Step 2: Get all policies
        <span class="cov8" title="1">allPolicies, err := pdp.storage.GetPolicies()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get policies: %w", err)
        }</span>

        // Step 3: Filter applicable policies
        <span class="cov8" title="1">applicablePolicies := pdp.filterApplicablePolicies(allPolicies, context)

        // Step 4: Sort policies by priority (ascending - lower number = higher priority)
        sort.Slice(applicablePolicies, func(i, j int) bool </span><span class="cov8" title="1">{
                return applicablePolicies[i].Priority &lt; applicablePolicies[j].Priority
        }</span>)

        // Step 5: Evaluate policies with short-circuit logic
        <span class="cov8" title="1">decision := pdp.evaluatePolicies(applicablePolicies, context)

        // Step 6: Calculate evaluation time
        evaluationTime := int(time.Since(startTime).Milliseconds())
        decision.EvaluationTimeMs = evaluationTime

        return decision, nil</span>
}

// filterApplicablePolicies filters policies that might apply to the request
func (pdp *PolicyDecisionPoint) filterApplicablePolicies(policies []*models.Policy, context *models.EvaluationContext) []*models.Policy <span class="cov8" title="1">{
        var applicable []*models.Policy

        for _, policy := range policies </span><span class="cov8" title="1">{
                if !policy.Enabled </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check if action matches
                <span class="cov8" title="1">if !pdp.actionMatches(policy.Actions, context.Action.ActionName) </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check if resource pattern matches
                <span class="cov8" title="1">if !pdp.resourcePatternMatches(policy.ResourcePatterns, context.Resource) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">applicable = append(applicable, policy)</span>
        }

        <span class="cov8" title="1">return applicable</span>
}

// actionMatches checks if the requested action matches policy actions
func (pdp *PolicyDecisionPoint) actionMatches(policyActions []string, requestedAction string) bool <span class="cov8" title="1">{
        if len(policyActions) == 0 </span><span class="cov8" title="1">{
                return true // No action restriction
        }</span>

        <span class="cov8" title="1">for _, action := range policyActions </span><span class="cov8" title="1">{
                if action == "*" || action == requestedAction </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// resourcePatternMatches checks if the resource matches any of the policy patterns
func (pdp *PolicyDecisionPoint) resourcePatternMatches(patterns []string, resource *models.Resource) bool <span class="cov8" title="1">{
        if len(patterns) == 0 </span><span class="cov8" title="1">{
                return true // No resource restriction
        }</span>

        <span class="cov8" title="1">resourcePath := resource.ResourceID
        if resource.Path != "" </span><span class="cov8" title="1">{
                resourcePath = resource.Path
        }</span>

        <span class="cov8" title="1">for _, pattern := range patterns </span><span class="cov8" title="1">{
                if pdp.attributeResolver.MatchResourcePattern(pattern, resourcePath) </span><span class="cov8" title="1">{
                        return true
                }</span>
                // Also check against resource ID
                <span class="cov8" title="1">if pdp.attributeResolver.MatchResourcePattern(pattern, resource.ResourceID) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// evaluatePolicies evaluates all applicable policies and returns final decision
func (pdp *PolicyDecisionPoint) evaluatePolicies(policies []*models.Policy, context *models.EvaluationContext) *models.Decision <span class="cov8" title="1">{
        var matchedPolicies []string
        var permitFound bool

        for _, policy := range policies </span><span class="cov8" title="1">{
                // Evaluate all rules in the policy
                if pdp.evaluatePolicy(policy, context) </span><span class="cov8" title="1">{
                        matchedPolicies = append(matchedPolicies, policy.ID)

                        if policy.Effect == "deny" </span><span class="cov8" title="1">{
                                // DENY overrides everything - short circuit
                                return &amp;models.Decision{
                                        Result:          "deny",
                                        MatchedPolicies: matchedPolicies,
                                        Reason:          fmt.Sprintf("Denied by policy: %s", policy.PolicyName),
                                }
                        }</span> else<span class="cov8" title="1"> if policy.Effect == "permit" </span><span class="cov8" title="1">{
                                permitFound = true
                        }</span>
                }
        }

        // Final decision logic
        <span class="cov8" title="1">if permitFound </span><span class="cov8" title="1">{
                return &amp;models.Decision{
                        Result:          "permit",
                        MatchedPolicies: matchedPolicies,
                        Reason:          "Access granted by matching permit policies",
                }
        }</span>

        <span class="cov8" title="1">return &amp;models.Decision{
                Result:          "not_applicable",
                MatchedPolicies: matchedPolicies,
                Reason:          "No applicable policies found",
        }</span>
}

// evaluatePolicy evaluates a single policy against the context
func (pdp *PolicyDecisionPoint) evaluatePolicy(policy *models.Policy, context *models.EvaluationContext) bool <span class="cov8" title="1">{
        // All rules must match (AND logic)
        for _, rule := range policy.Rules </span><span class="cov8" title="1">{
                if !pdp.evaluateRule(rule, context) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// evaluateRule evaluates a single rule against the context
func (pdp *PolicyDecisionPoint) evaluateRule(rule models.PolicyRule, context *models.EvaluationContext) bool <span class="cov8" title="1">{
        // Get the actual value based on target type
        var actualValue interface{}

        switch rule.TargetType </span>{
        case "subject":<span class="cov8" title="1">
                actualValue = pdp.attributeResolver.GetAttributeValue(context.Subject, rule.AttributePath)</span>
        case "resource":<span class="cov8" title="1">
                actualValue = pdp.attributeResolver.GetAttributeValue(context.Resource, rule.AttributePath)</span>
        case "action":<span class="cov0" title="0">
                actualValue = pdp.attributeResolver.GetAttributeValue(context.Action, rule.AttributePath)</span>
        case "environment":<span class="cov8" title="1">
                actualValue = pdp.attributeResolver.GetAttributeValue(context.Environment, rule.AttributePath)</span>
        default:<span class="cov0" title="0">
                return false</span>
        }

        // Get the operator
        <span class="cov8" title="1">operator, err := pdp.operatorRegistry.Get(rule.Operator)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Evaluate the rule
        <span class="cov8" title="1">result := operator.Evaluate(actualValue, rule.ExpectedValue)

        // Apply negation if needed
        if rule.IsNegative </span><span class="cov0" title="0">{
                result = !result
        }</span>

        <span class="cov8" title="1">return result</span>
}

// BatchEvaluate evaluates multiple requests in parallel
func (pdp *PolicyDecisionPoint) BatchEvaluate(requests []*models.EvaluationRequest) ([]*models.Decision, error) <span class="cov8" title="1">{
        decisions := make([]*models.Decision, len(requests))
        errors := make([]error, len(requests))

        // Simple sequential evaluation (could be parallelized with goroutines)
        for i, request := range requests </span><span class="cov8" title="1">{
                decision, err := pdp.Evaluate(request)
                decisions[i] = decision
                errors[i] = err
        }</span>

        // Check if any errors occurred
        <span class="cov8" title="1">for _, err := range errors </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return decisions, err
                }</span>
        }

        <span class="cov8" title="1">return decisions, nil</span>
}

// GetApplicablePolicies returns policies that would apply to a request (for debugging)
func (pdp *PolicyDecisionPoint) GetApplicablePolicies(request *models.EvaluationRequest) ([]*models.Policy, error) <span class="cov8" title="1">{
        context, err := pdp.attributeResolver.EnrichContext(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to enrich context: %w", err)
        }</span>

        <span class="cov8" title="1">allPolicies, err := pdp.storage.GetPolicies()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get policies: %w", err)
        }</span>

        <span class="cov8" title="1">return pdp.filterApplicablePolicies(allPolicies, context), nil</span>
}

// ExplainDecision provides detailed explanation of how a decision was reached
func (pdp *PolicyDecisionPoint) ExplainDecision(request *models.EvaluationRequest) (map[string]interface{}, error) <span class="cov8" title="1">{
        context, err := pdp.attributeResolver.EnrichContext(request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to enrich context: %w", err)
        }</span>

        <span class="cov8" title="1">allPolicies, err := pdp.storage.GetPolicies()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get policies: %w", err)
        }</span>

        <span class="cov8" title="1">applicablePolicies := pdp.filterApplicablePolicies(allPolicies, context)

        explanation := map[string]interface{}{
                "request":             request,
                "context":             context,
                "total_policies":      len(allPolicies),
                "applicable_policies": len(applicablePolicies),
                "policy_evaluations":  []map[string]interface{}{},
        }

        // Evaluate each policy and record results
        policyEvaluations := []map[string]interface{}{}
        for _, policy := range applicablePolicies </span><span class="cov8" title="1">{
                policyResult := map[string]interface{}{
                        "policy_id":   policy.ID,
                        "policy_name": policy.PolicyName,
                        "effect":      policy.Effect,
                        "priority":    policy.Priority,
                        "matched":     false,
                        "rules":       []map[string]interface{}{},
                }

                allRulesMatch := true
                ruleResults := []map[string]interface{}{}

                for _, rule := range policy.Rules </span><span class="cov8" title="1">{
                        var actualValue interface{}
                        switch rule.TargetType </span>{
                        case "subject":<span class="cov8" title="1">
                                actualValue = pdp.attributeResolver.GetAttributeValue(context.Subject, rule.AttributePath)</span>
                        case "resource":<span class="cov8" title="1">
                                actualValue = pdp.attributeResolver.GetAttributeValue(context.Resource, rule.AttributePath)</span>
                        case "action":<span class="cov0" title="0">
                                actualValue = pdp.attributeResolver.GetAttributeValue(context.Action, rule.AttributePath)</span>
                        case "environment":<span class="cov8" title="1">
                                actualValue = pdp.attributeResolver.GetAttributeValue(context.Environment, rule.AttributePath)</span>
                        }

                        <span class="cov8" title="1">operator, _ := pdp.operatorRegistry.Get(rule.Operator)
                        ruleMatch := false
                        if operator != nil </span><span class="cov8" title="1">{
                                ruleMatch = operator.Evaluate(actualValue, rule.ExpectedValue)
                                if rule.IsNegative </span><span class="cov0" title="0">{
                                        ruleMatch = !ruleMatch
                                }</span>
                        }

                        <span class="cov8" title="1">if !ruleMatch </span><span class="cov0" title="0">{
                                allRulesMatch = false
                        }</span>

                        <span class="cov8" title="1">ruleResults = append(ruleResults, map[string]interface{}{
                                "target_type":    rule.TargetType,
                                "attribute_path": rule.AttributePath,
                                "operator":       rule.Operator,
                                "expected_value": rule.ExpectedValue,
                                "actual_value":   actualValue,
                                "matched":        ruleMatch,
                                "is_negative":    rule.IsNegative,
                        })</span>
                }

                <span class="cov8" title="1">policyResult["matched"] = allRulesMatch
                policyResult["rules"] = ruleResults
                policyEvaluations = append(policyEvaluations, policyResult)</span>
        }

        <span class="cov8" title="1">explanation["policy_evaluations"] = policyEvaluations
        return explanation, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "encoding/json"
        "fmt"
        "log"
        "os"
        "time"

        "abac_go_example/audit"
        "abac_go_example/evaluator"
        "abac_go_example/models"
        "abac_go_example/storage"
)

func main() <span class="cov0" title="0">{
        fmt.Println("🚀 ABAC Policy Evaluation System")
        fmt.Println("==================================")

        // Initialize storage with JSON data
        mockStorage, err := storage.NewMockStorage(".")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize storage: %v", err)
        }</span>

        // Initialize audit logger
        <span class="cov0" title="0">auditLogger, err := audit.NewAuditLogger("audit.log")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize audit logger: %v", err)
        }</span>
        <span class="cov0" title="0">defer auditLogger.Close()

        // Initialize Policy Decision Point
        pdp := evaluator.NewPolicyDecisionPoint(mockStorage)

        // Load evaluation requests from JSON
        evaluationRequests, err := loadEvaluationRequests("evaluation_requests.json")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to load evaluation requests: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n📋 Running %d evaluation scenarios...\n\n", len(evaluationRequests))

        // Process each evaluation request
        for i, request := range evaluationRequests </span><span class="cov0" title="0">{
                fmt.Printf("🔍 Scenario %d: %s\n", i+1, request.RequestID)
                fmt.Printf("   Subject: %s\n", request.SubjectID)
                fmt.Printf("   Resource: %s\n", request.ResourceID)
                fmt.Printf("   Action: %s\n", request.Action)

                // Perform evaluation
                decision, err := pdp.Evaluate(request)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("   ❌ Error: %v\n\n", err)
                        continue</span>
                }

                // Get full context for audit logging
                <span class="cov0" title="0">subject, _ := mockStorage.GetSubject(request.SubjectID)
                resource, _ := mockStorage.GetResource(request.ResourceID)
                action, _ := mockStorage.GetAction(request.Action)

                auditContext := &amp;models.EvaluationContext{
                        Subject:     subject,
                        Resource:    resource,
                        Action:      action,
                        Environment: request.Context,
                        Timestamp:   time.Now(),
                }

                // Log the evaluation
                auditLogger.LogEvaluation(request, decision, auditContext)

                // Display results
                fmt.Printf("   📊 Decision: %s\n", decision.Result)
                fmt.Printf("   ⏱️  Evaluation Time: %dms\n", decision.EvaluationTimeMs)
                fmt.Printf("   📝 Reason: %s\n", decision.Reason)

                if len(decision.MatchedPolicies) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("   🎯 Matched Policies: %v\n", decision.MatchedPolicies)
                }</span>

                // Check expected result if available
                <span class="cov0" title="0">if expectedDecision, ok := request.Context["expected_decision"].(string); ok </span><span class="cov0" title="0">{
                        if decision.Result == expectedDecision </span><span class="cov0" title="0">{
                                fmt.Printf("   ✅ Expected: %s (PASS)\n", expectedDecision)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("   ❌ Expected: %s, Got: %s (FAIL)\n", expectedDecision, decision.Result)
                        }</span>
                }

                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Display system statistics
        <span class="cov0" title="0">fmt.Println("📈 System Statistics")
        fmt.Println("===================")

        subjects, _ := mockStorage.GetAllSubjects()
        resources, _ := mockStorage.GetAllResources()
        actions, _ := mockStorage.GetAllActions()
        policies, _ := mockStorage.GetPolicies()

        fmt.Printf("Subjects: %d\n", len(subjects))
        fmt.Printf("Resources: %d\n", len(resources))
        fmt.Printf("Actions: %d\n", len(actions))
        fmt.Printf("Policies: %d\n", len(policies))

        // Test detailed explanation for first request
        if len(evaluationRequests) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("\n🔬 Detailed Explanation for First Request")
                fmt.Println("=========================================")

                explanation, err := pdp.ExplainDecision(evaluationRequests[0])
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error getting explanation: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        explanationJSON, _ := json.MarshalIndent(explanation, "", "  ")
                        fmt.Println(string(explanationJSON))
                }</span>
        }

        // Test batch evaluation
        <span class="cov0" title="0">fmt.Println("\n⚡ Batch Evaluation Test")
        fmt.Println("=======================")

        startTime := time.Now()
        decisions, err := pdp.BatchEvaluate(evaluationRequests)
        batchTime := time.Since(startTime)

        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Batch evaluation error: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Batch processed %d requests in %v\n", len(decisions), batchTime)
                fmt.Printf("Average time per request: %v\n", batchTime/time.Duration(len(decisions)))
        }</span>

        // Test security scenarios
        <span class="cov0" title="0">fmt.Println("\n🔐 Security Scenarios")
        fmt.Println("====================")

        testSecurityScenarios(pdp, auditLogger)

        fmt.Println("\n✅ ABAC System Demo Complete!")</span>
}

func loadEvaluationRequests(filename string) ([]*models.EvaluationRequest, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read file: %w", err)
        }</span>

        <span class="cov0" title="0">var requestsData struct {
                EvaluationRequests []*models.EvaluationRequest `json:"evaluation_requests"`
        }

        if err := json.Unmarshal(data, &amp;requestsData); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal JSON: %w", err)
        }</span>

        // Add expected decisions from the JSON data
        <span class="cov0" title="0">for _, req := range requestsData.EvaluationRequests </span><span class="cov0" title="0">{
                if req.Context == nil </span><span class="cov0" title="0">{
                        req.Context = make(map[string]interface{})
                }</span>

                // Look for expected_decision in the original JSON structure
                <span class="cov0" title="0">var originalData map[string]interface{}
                json.Unmarshal(data, &amp;originalData)

                if evalRequests, ok := originalData["evaluation_requests"].([]interface{}); ok </span><span class="cov0" title="0">{
                        for _, evalReq := range evalRequests </span><span class="cov0" title="0">{
                                if reqMap, ok := evalReq.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if reqMap["request_id"] == req.RequestID </span><span class="cov0" title="0">{
                                                if expectedDecision, exists := reqMap["expected_decision"]; exists </span><span class="cov0" title="0">{
                                                        req.Context["expected_decision"] = expectedDecision
                                                }</span>
                                                <span class="cov0" title="0">if matchedPolicies, exists := reqMap["matched_policies"]; exists </span><span class="cov0" title="0">{
                                                        req.Context["expected_matched_policies"] = matchedPolicies
                                                }</span>
                                                <span class="cov0" title="0">break</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov0" title="0">return requestsData.EvaluationRequests, nil</span>
}

func testSecurityScenarios(pdp *evaluator.PolicyDecisionPoint, auditLogger *audit.AuditLogger) <span class="cov0" title="0">{
        // Test 1: Probation user trying to write
        fmt.Println("1. Testing probation user write access...")
        probationRequest := &amp;models.EvaluationRequest{
                RequestID:  "security-test-1",
                SubjectID:  "sub-004", // Bob Wilson (on probation)
                ResourceID: "res-002", // Production database
                Action:     "write",
                Context: map[string]interface{}{
                        "timestamp": time.Now().Format(time.RFC3339),
                        "source_ip": "10.0.1.100",
                },
        }

        decision, err := pdp.Evaluate(probationRequest)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("   Error: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("   Result: %s (Expected: deny)\n", decision.Result)
                fmt.Printf("   Reason: %s\n", decision.Reason)

                if decision.Result == "deny" </span><span class="cov0" title="0">{
                        auditLogger.LogSecurityEvent("probation_write_attempt", "sub-004", map[string]interface{}{
                                "resource": "res-002",
                                "action":   "write",
                                "blocked":  true,
                        })
                }</span>
        }

        // Test 2: After hours access attempt
        <span class="cov0" title="0">fmt.Println("\n2. Testing after-hours access...")
        afterHoursRequest := &amp;models.EvaluationRequest{
                RequestID:  "security-test-2",
                SubjectID:  "sub-001", // John Doe (senior developer)
                ResourceID: "res-001", // API endpoint
                Action:     "write",
                Context: map[string]interface{}{
                        "timestamp": "2024-01-15T22:00:00Z", // 10 PM
                        "source_ip": "10.0.1.50",
                },
        }

        decision, err = pdp.Evaluate(afterHoursRequest)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("   Error: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("   Result: %s\n", decision.Result)
                fmt.Printf("   Reason: %s\n", decision.Reason)
        }</span>

        // Test 3: External IP access attempt
        <span class="cov0" title="0">fmt.Println("\n3. Testing external IP access...")
        externalIPRequest := &amp;models.EvaluationRequest{
                RequestID:  "security-test-3",
                SubjectID:  "sub-003", // Payment service
                ResourceID: "res-001", // API endpoint
                Action:     "read",
                Context: map[string]interface{}{
                        "timestamp": time.Now().Format(time.RFC3339),
                        "source_ip": "203.0.113.1", // External IP
                },
        }

        decision, err = pdp.Evaluate(externalIPRequest)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("   Error: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("   Result: %s\n", decision.Result)
                fmt.Printf("   Reason: %s\n", decision.Reason)

                if decision.Result == "deny" </span><span class="cov0" title="0">{
                        auditLogger.LogSecurityEvent("external_ip_access", "sub-003", map[string]interface{}{
                                "source_ip": "203.0.113.1",
                                "resource":  "res-001",
                                "blocked":   true,
                        })
                }</span>
        }

        // Test 4: Privilege escalation attempt
        <span class="cov0" title="0">fmt.Println("\n4. Testing privilege escalation...")
        escalationRequest := &amp;models.EvaluationRequest{
                RequestID:  "security-test-4",
                SubjectID:  "sub-004", // Junior developer
                ResourceID: "res-003", // Financial document
                Action:     "read",
                Context: map[string]interface{}{
                        "timestamp": time.Now().Format(time.RFC3339),
                        "source_ip": "10.0.1.200",
                },
        }

        decision, err = pdp.Evaluate(escalationRequest)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("   Error: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("   Result: %s\n", decision.Result)
                fmt.Printf("   Reason: %s\n", decision.Reason)

                if decision.Result == "deny" </span><span class="cov0" title="0">{
                        auditLogger.LogSecurityEvent("privilege_escalation_attempt", "sub-004", map[string]interface{}{
                                "attempted_resource": "res-003",
                                "resource_type":      "financial_document",
                                "user_clearance":     1,
                                "required_clearance": 2,
                        })
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package operators

import (
        "fmt"
        "reflect"
        "regexp"
        "strconv"
        "strings"
)

// Operator interface defines the contract for rule operators
type Operator interface {
        Evaluate(actual, expected interface{}) bool
}

// OperatorRegistry holds all available operators
type OperatorRegistry struct {
        operators map[string]Operator
}

// NewOperatorRegistry creates a new operator registry with default operators
func NewOperatorRegistry() *OperatorRegistry <span class="cov8" title="1">{
        registry := &amp;OperatorRegistry{
                operators: make(map[string]Operator),
        }

        // Register default operators
        registry.Register("eq", &amp;EqualOperator{})
        registry.Register("neq", &amp;NotEqualOperator{})
        registry.Register("in", &amp;InOperator{})
        registry.Register("nin", &amp;NotInOperator{})
        registry.Register("contains", &amp;ContainsOperator{})
        registry.Register("regex", &amp;RegexOperator{})
        registry.Register("gt", &amp;GreaterThanOperator{})
        registry.Register("gte", &amp;GreaterThanEqualOperator{})
        registry.Register("lt", &amp;LessThanOperator{})
        registry.Register("lte", &amp;LessThanEqualOperator{})
        registry.Register("between", &amp;BetweenOperator{})
        registry.Register("exists", &amp;ExistsOperator{})

        return registry
}</span>

// Register adds an operator to the registry
func (r *OperatorRegistry) Register(name string, operator Operator) <span class="cov8" title="1">{
        r.operators[name] = operator
}</span>

// Get retrieves an operator by name
func (r *OperatorRegistry) Get(name string) (Operator, error) <span class="cov8" title="1">{
        operator, exists := r.operators[name]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("operator not found: %s", name)
        }</span>
        <span class="cov8" title="1">return operator, nil</span>
}

// EqualOperator implements exact equality comparison
type EqualOperator struct{}

func (o *EqualOperator) Evaluate(actual, expected interface{}) bool <span class="cov8" title="1">{
        return reflect.DeepEqual(actual, expected)
}</span>

// NotEqualOperator implements inequality comparison
type NotEqualOperator struct{}

func (o *NotEqualOperator) Evaluate(actual, expected interface{}) bool <span class="cov0" title="0">{
        return !reflect.DeepEqual(actual, expected)
}</span>

// InOperator checks if actual value is in expected array
type InOperator struct{}

func (o *InOperator) Evaluate(actual, expected interface{}) bool <span class="cov8" title="1">{
        expectedSlice := toSlice(expected)
        if expectedSlice == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, item := range expectedSlice </span><span class="cov8" title="1">{
                if reflect.DeepEqual(actual, item) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// NotInOperator checks if actual value is not in expected array
type NotInOperator struct{}

func (o *NotInOperator) Evaluate(actual, expected interface{}) bool <span class="cov0" title="0">{
        inOp := &amp;InOperator{}
        return !inOp.Evaluate(actual, expected)
}</span>

// ContainsOperator checks if actual array contains expected value
type ContainsOperator struct{}

func (o *ContainsOperator) Evaluate(actual, expected interface{}) bool <span class="cov8" title="1">{
        actualSlice := toSlice(actual)
        if actualSlice == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, item := range actualSlice </span><span class="cov8" title="1">{
                if reflect.DeepEqual(item, expected) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// RegexOperator performs regular expression matching
type RegexOperator struct{}

func (o *RegexOperator) Evaluate(actual, expected interface{}) bool <span class="cov8" title="1">{
        actualStr := toString(actual)
        expectedStr := toString(expected)
        
        if expectedStr == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">matched, err := regexp.MatchString(expectedStr, actualStr)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return matched</span>
}

// GreaterThanOperator performs &gt; comparison
type GreaterThanOperator struct{}

func (o *GreaterThanOperator) Evaluate(actual, expected interface{}) bool <span class="cov8" title="1">{
        return compareNumbers(actual, expected) &gt; 0
}</span>

// GreaterThanEqualOperator performs &gt;= comparison
type GreaterThanEqualOperator struct{}

func (o *GreaterThanEqualOperator) Evaluate(actual, expected interface{}) bool <span class="cov0" title="0">{
        return compareNumbers(actual, expected) &gt;= 0
}</span>

// LessThanOperator performs &lt; comparison
type LessThanOperator struct{}

func (o *LessThanOperator) Evaluate(actual, expected interface{}) bool <span class="cov0" title="0">{
        return compareNumbers(actual, expected) &lt; 0
}</span>

// LessThanEqualOperator performs &lt;= comparison
type LessThanEqualOperator struct{}

func (o *LessThanEqualOperator) Evaluate(actual, expected interface{}) bool <span class="cov0" title="0">{
        return compareNumbers(actual, expected) &lt;= 0
}</span>

// BetweenOperator checks if value is between two bounds (inclusive)
type BetweenOperator struct{}

func (o *BetweenOperator) Evaluate(actual, expected interface{}) bool <span class="cov8" title="1">{
        expectedSlice := toSlice(expected)
        if expectedSlice == nil || len(expectedSlice) != 2 </span><span class="cov8" title="1">{
                return false
        }</span>

        // For time-based comparisons (like time_of_day)
        <span class="cov8" title="1">if actualStr := toString(actual); actualStr != "" </span><span class="cov8" title="1">{
                if strings.Contains(actualStr, ":") </span><span class="cov8" title="1">{
                        return isTimeBetween(actualStr, toString(expectedSlice[0]), toString(expectedSlice[1]))
                }</span>
        }

        // For numeric comparisons
        <span class="cov8" title="1">actualNum := toFloat64(actual)
        lowerNum := toFloat64(expectedSlice[0])
        upperNum := toFloat64(expectedSlice[1])

        return actualNum &gt;= lowerNum &amp;&amp; actualNum &lt;= upperNum</span>
}

// ExistsOperator checks if a value exists (is not nil)
type ExistsOperator struct{}

func (o *ExistsOperator) Evaluate(actual, expected interface{}) bool <span class="cov8" title="1">{
        return actual != nil
}</span>

// Helper functions

func toSlice(value interface{}) []interface{} <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">v := reflect.ValueOf(value)
        if v.Kind() != reflect.Slice &amp;&amp; v.Kind() != reflect.Array </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">result := make([]interface{}, v.Len())
        for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                result[i] = v.Index(i).Interface()
        }</span>
        <span class="cov8" title="1">return result</span>
}

func toString(value interface{}) string <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">switch v := value.(type) </span>{
        case string:<span class="cov8" title="1">
                return v</span>
        case fmt.Stringer:<span class="cov0" title="0">
                return v.String()</span>
        default:<span class="cov8" title="1">
                return fmt.Sprintf("%v", v)</span>
        }
}

func toFloat64(value interface{}) float64 <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">switch v := value.(type) </span>{
        case int:<span class="cov8" title="1">
                return float64(v)</span>
        case int32:<span class="cov0" title="0">
                return float64(v)</span>
        case int64:<span class="cov0" title="0">
                return float64(v)</span>
        case float32:<span class="cov0" title="0">
                return float64(v)</span>
        case float64:<span class="cov8" title="1">
                return v</span>
        case string:<span class="cov8" title="1">
                if f, err := strconv.ParseFloat(v, 64); err == nil </span><span class="cov8" title="1">{
                        return f
                }</span>
        }
        <span class="cov8" title="1">return 0</span>
}

func compareNumbers(actual, expected interface{}) int <span class="cov8" title="1">{
        actualNum := toFloat64(actual)
        expectedNum := toFloat64(expected)

        if actualNum &gt; expectedNum </span><span class="cov8" title="1">{
                return 1
        }</span> else<span class="cov8" title="1"> if actualNum &lt; expectedNum </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">return 0</span>
}

func isTimeBetween(timeStr, startStr, endStr string) bool <span class="cov8" title="1">{
        // Parse time strings in HH:MM format
        parseTime := func(s string) (int, int, error) </span><span class="cov8" title="1">{
                parts := strings.Split(s, ":")
                if len(parts) != 2 </span><span class="cov8" title="1">{
                        return 0, 0, fmt.Errorf("invalid time format")
                }</span>
                <span class="cov8" title="1">hour, err1 := strconv.Atoi(parts[0])
                minute, err2 := strconv.Atoi(parts[1])
                if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                        return 0, 0, fmt.Errorf("invalid time format")
                }</span>
                <span class="cov8" title="1">return hour, minute, nil</span>
        }

        <span class="cov8" title="1">timeHour, timeMin, err1 := parseTime(timeStr)
        startHour, startMin, err2 := parseTime(startStr)
        endHour, endMin, err3 := parseTime(endStr)

        if err1 != nil || err2 != nil || err3 != nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">timeMinutes := timeHour*60 + timeMin
        startMinutes := startHour*60 + startMin
        endMinutes := endHour*60 + endMin

        return timeMinutes &gt;= startMinutes &amp;&amp; timeMinutes &lt;= endMinutes</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package storage

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "path/filepath"

        "abac_go_example/models"
)

// Storage interface defines the contract for data access
type Storage interface {
        GetSubject(id string) (*models.Subject, error)
        GetResource(id string) (*models.Resource, error)
        GetAction(name string) (*models.Action, error)
        GetPolicies() ([]*models.Policy, error)
        GetAllSubjects() ([]*models.Subject, error)
        GetAllResources() ([]*models.Resource, error)
        GetAllActions() ([]*models.Action, error)
}

// MockStorage implements Storage interface using JSON files
type MockStorage struct {
        subjects  map[string]*models.Subject
        resources map[string]*models.Resource
        actions   map[string]*models.Action
        policies  []*models.Policy
}

// NewMockStorage creates a new MockStorage instance
func NewMockStorage(dataDir string) (*MockStorage, error) <span class="cov8" title="1">{
        storage := &amp;MockStorage{
                subjects:  make(map[string]*models.Subject),
                resources: make(map[string]*models.Resource),
                actions:   make(map[string]*models.Action),
        }

        if err := storage.loadData(dataDir); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to load data: %w", err)
        }</span>

        <span class="cov8" title="1">return storage, nil</span>
}

func (s *MockStorage) loadData(dataDir string) error <span class="cov8" title="1">{
        // Load subjects
        if err := s.loadSubjects(filepath.Join(dataDir, "subjects.json")); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to load subjects: %w", err)
        }</span>

        // Load resources
        <span class="cov8" title="1">if err := s.loadResources(filepath.Join(dataDir, "resources.json")); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load resources: %w", err)
        }</span>

        // Load actions
        <span class="cov8" title="1">if err := s.loadActions(filepath.Join(dataDir, "actions.json")); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load actions: %w", err)
        }</span>

        // Load policies
        <span class="cov8" title="1">if err := s.loadPolicies(filepath.Join(dataDir, "policies.json")); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load policies: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *MockStorage) loadSubjects(filename string) error <span class="cov8" title="1">{
        data, err := ioutil.ReadFile(filename)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">var subjectsData struct {
                Subjects []*models.Subject `json:"subjects"`
        }

        if err := json.Unmarshal(data, &amp;subjectsData); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">for _, subject := range subjectsData.Subjects </span><span class="cov8" title="1">{
                s.subjects[subject.ID] = subject
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *MockStorage) loadResources(filename string) error <span class="cov8" title="1">{
        data, err := ioutil.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var resourcesData struct {
                Resources []*models.Resource `json:"resources"`
        }

        if err := json.Unmarshal(data, &amp;resourcesData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, resource := range resourcesData.Resources </span><span class="cov8" title="1">{
                s.resources[resource.ID] = resource
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *MockStorage) loadActions(filename string) error <span class="cov8" title="1">{
        data, err := ioutil.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var actionsData struct {
                Actions []*models.Action `json:"actions"`
        }

        if err := json.Unmarshal(data, &amp;actionsData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, action := range actionsData.Actions </span><span class="cov8" title="1">{
                s.actions[action.ActionName] = action
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *MockStorage) loadPolicies(filename string) error <span class="cov8" title="1">{
        data, err := ioutil.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var policiesData struct {
                Policies []*models.Policy `json:"policies"`
        }

        if err := json.Unmarshal(data, &amp;policiesData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">s.policies = policiesData.Policies
        return nil</span>
}

// GetSubject retrieves a subject by ID
func (s *MockStorage) GetSubject(id string) (*models.Subject, error) <span class="cov8" title="1">{
        subject, exists := s.subjects[id]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("subject not found: %s", id)
        }</span>
        <span class="cov8" title="1">return subject, nil</span>
}

// GetResource retrieves a resource by ID
func (s *MockStorage) GetResource(id string) (*models.Resource, error) <span class="cov8" title="1">{
        resource, exists := s.resources[id]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("resource not found: %s", id)
        }</span>
        <span class="cov8" title="1">return resource, nil</span>
}

// GetAction retrieves an action by name
func (s *MockStorage) GetAction(name string) (*models.Action, error) <span class="cov8" title="1">{
        action, exists := s.actions[name]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("action not found: %s", name)
        }</span>
        <span class="cov8" title="1">return action, nil</span>
}

// GetPolicies retrieves all policies
func (s *MockStorage) GetPolicies() ([]*models.Policy, error) <span class="cov8" title="1">{
        return s.policies, nil
}</span>

// GetAllSubjects retrieves all subjects
func (s *MockStorage) GetAllSubjects() ([]*models.Subject, error) <span class="cov8" title="1">{
        subjects := make([]*models.Subject, 0, len(s.subjects))
        for _, subject := range s.subjects </span><span class="cov8" title="1">{
                subjects = append(subjects, subject)
        }</span>
        <span class="cov8" title="1">return subjects, nil</span>
}

// GetAllResources retrieves all resources
func (s *MockStorage) GetAllResources() ([]*models.Resource, error) <span class="cov8" title="1">{
        resources := make([]*models.Resource, 0, len(s.resources))
        for _, resource := range s.resources </span><span class="cov8" title="1">{
                resources = append(resources, resource)
        }</span>
        <span class="cov8" title="1">return resources, nil</span>
}

// GetAllActions retrieves all actions
func (s *MockStorage) GetAllActions() ([]*models.Action, error) <span class="cov8" title="1">{
        actions := make([]*models.Action, 0, len(s.actions))
        for _, action := range s.actions </span><span class="cov8" title="1">{
                actions = append(actions, action)
        }</span>
        <span class="cov8" title="1">return actions, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
