package main

import (
	"encoding/json"
	"fmt"

	"abac_go_example/evaluator"
	"abac_go_example/models"
)

func main() {
	fmt.Println("=== Demo New Policy JSON Format ===")

	// Create PDP instance (not used in this demo)
	// pdp := evaluator.NewPolicyDecisionPoint(nil)

	// Test cases based on the policy examples
	testCases := []struct {
		name        string
		request     *models.EvaluationRequest
		context     map[string]interface{}
		expected    string
		description string
	}{
		{
			name: "Own Document Access",
			request: &models.EvaluationRequest{
				RequestID:  "req-001",
				SubjectID:  "user-123",
				ResourceID: "api:documents:owner:user-123/file-1",
				Action:     "document-service:file:read",
				Context: map[string]interface{}{
					"timestamp": "2024-10-21T10:00:00Z",
				},
			},
			context: map[string]interface{}{
				"request:UserId":     "user-123",
				"request:Action":     "document-service:file:read",
				"request:ResourceId": "api:documents:owner:user-123/file-1",
				"user:Department":    "engineering",
			},
			expected:    "permit",
			description: "User should be able to access their own documents",
		},
		{
			name: "Department Document Read - Non-Confidential",
			request: &models.EvaluationRequest{
				RequestID:  "req-002",
				SubjectID:  "user-456",
				ResourceID: "api:documents:dept:engineering/file-2",
				Action:     "document-service:file:read",
				Context: map[string]interface{}{
					"timestamp": "2024-10-21T10:00:00Z",
				},
			},
			context: map[string]interface{}{
				"request:UserId":     "user-456",
				"request:Action":     "document-service:file:read",
				"request:ResourceId": "api:documents:dept:engineering/file-2",
				"user:Department":    "engineering",
				"resource": map[string]interface{}{
					"sensitivity": "public",
				},
			},
			expected:    "permit",
			description: "User should be able to read non-confidential department documents",
		},
		{
			name: "Confidential Document Delete - Denied",
			request: &models.EvaluationRequest{
				RequestID:  "req-003",
				SubjectID:  "user-789",
				ResourceID: "api:documents:doc-456",
				Action:     "document-service:file:delete",
				Context: map[string]interface{}{
					"timestamp": "2024-10-21T10:00:00Z",
				},
			},
			context: map[string]interface{}{
				"request:UserId":     "user-789",
				"request:Action":     "document-service:file:delete",
				"request:ResourceId": "api:documents:doc-456",
				"user:Department":    "engineering",
				"resource": map[string]interface{}{
					"sensitivity": "confidential",
				},
			},
			expected:    "deny",
			description: "Confidential documents cannot be deleted (deny override)",
		},
		{
			name: "Small Transaction Approval",
			request: &models.EvaluationRequest{
				RequestID:  "req-004",
				SubjectID:  "user-manager",
				ResourceID: "api:transactions:txn-123",
				Action:     "payment-service:transaction:approve",
				Context: map[string]interface{}{
					"timestamp": "2024-10-21T10:00:00Z",
				},
			},
			context: map[string]interface{}{
				"request:UserId":     "user-manager",
				"request:Action":     "payment-service:transaction:approve",
				"request:ResourceId": "api:transactions:txn-123",
				"user:Role":          "employee",
				"transaction": map[string]interface{}{
					"amount": 500000, // Less than 1M
				},
			},
			expected:    "permit",
			description: "Small transactions can be approved by any user",
		},
		{
			name: "Large Transaction - Need Manager",
			request: &models.EvaluationRequest{
				RequestID:  "req-005",
				SubjectID:  "user-employee",
				ResourceID: "api:transactions:txn-456",
				Action:     "payment-service:transaction:approve",
				Context: map[string]interface{}{
					"timestamp": "2024-10-21T10:00:00Z",
				},
			},
			context: map[string]interface{}{
				"request:UserId":     "user-employee",
				"request:Action":     "payment-service:transaction:approve",
				"request:ResourceId": "api:transactions:txn-456",
				"user:Role":          "employee", // Not manager
				"transaction": map[string]interface{}{
					"amount": 2000000, // Greater than 1M
				},
			},
			expected:    "deny",
			description: "Large transactions need manager approval",
		},
		{
			name: "External IP Access - Denied",
			request: &models.EvaluationRequest{
				RequestID:  "req-006",
				SubjectID:  "user-external",
				ResourceID: "api:documents:doc-789",
				Action:     "document-service:file:read",
				Context: map[string]interface{}{
					"timestamp": "2024-10-21T10:00:00Z",
					"sourceIp":  "203.0.113.1", // External IP
				},
			},
			context: map[string]interface{}{
				"request:UserId":     "user-external",
				"request:Action":     "document-service:file:read",
				"request:ResourceId": "api:documents:doc-789",
				"request:SourceIp":   "203.0.113.1",
				"request:IsExternal": true,
			},
			expected:    "deny",
			description: "External access should be denied",
		},
	}

	// Create sample policies
	policies := createSamplePolicies()

	// Run test cases
	for i, testCase := range testCases {
		fmt.Printf("\n--- Test Case %d: %s ---\n", i+1, testCase.name)
		fmt.Printf("Description: %s\n", testCase.description)

		// Create PDP with sample policies
		pdpWithPolicies := evaluator.NewPolicyDecisionPoint(nil)

		// Evaluate using new format
		decision := evaluateNewPolicies(pdpWithPolicies, policies, testCase.context)

		fmt.Printf("Request: %s on %s\n", testCase.request.Action, testCase.request.ResourceID)
		fmt.Printf("Expected: %s\n", testCase.expected)
		fmt.Printf("Actual: %s\n", decision.Result)
		fmt.Printf("Reason: %s\n", decision.Reason)

		if decision.Result == testCase.expected {
			fmt.Printf("✅ PASS\n")
		} else {
			fmt.Printf("❌ FAIL\n")
		}
	}

	// Demo wildcard matching
	fmt.Printf("\n=== Wildcard Matching Demo ===\n")
	demoWildcardMatching()

	// Demo condition evaluation
	fmt.Printf("\n=== Condition Evaluation Demo ===\n")
	demoConditionEvaluation()
}

func createSamplePolicies() []*models.Policy {
	return []*models.Policy{
		{
			ID:      "pol-001",
			Enabled: true,
			Statement: []models.PolicyStatement{
				{
					Sid:    "OwnDocumentsFullAccess",
					Effect: "Allow",
					Action: models.JSONActionResource{
						Single:  "document-service:file:*",
						IsArray: false,
					},
					Resource: models.JSONActionResource{
						Single:  "api:documents:owner:${request:UserId}/*",
						IsArray: false,
					},
				},
				{
					Sid:    "DepartmentDocumentsRead",
					Effect: "Allow",
					Action: models.JSONActionResource{
						Multiple: []string{"document-service:file:read", "document-service:file:list"},
						IsArray:  true,
					},
					Resource: models.JSONActionResource{
						Single:  "api:documents:dept:${user:Department}/*",
						IsArray: false,
					},
					Condition: map[string]interface{}{
						"StringNotEquals": map[string]interface{}{
							"resource.sensitivity": "confidential",
						},
					},
				},
				{
					Sid:    "DenyConfidentialDelete",
					Effect: "Deny",
					Action: models.JSONActionResource{
						Single:  "document-service:file:delete",
						IsArray: false,
					},
					Resource: models.JSONActionResource{
						Single:  "*",
						IsArray: false,
					},
					Condition: map[string]interface{}{
						"StringEquals": map[string]interface{}{
							"resource.sensitivity": "confidential",
						},
					},
				},
			},
		},
		{
			ID:      "pol-002",
			Enabled: true,
			Statement: []models.PolicyStatement{
				{
					Sid:    "SmallTransactions",
					Effect: "Allow",
					Action: models.JSONActionResource{
						Single:  "payment-service:transaction:approve",
						IsArray: false,
					},
					Resource: models.JSONActionResource{
						Single:  "api:transactions:*",
						IsArray: false,
					},
					Condition: map[string]interface{}{
						"NumericLessThan": map[string]interface{}{
							"transaction.amount": 1000000,
						},
					},
				},
				{
					Sid:    "LargeTransactionsNeedManager",
					Effect: "Allow",
					Action: models.JSONActionResource{
						Single:  "payment-service:transaction:approve",
						IsArray: false,
					},
					Resource: models.JSONActionResource{
						Single:  "api:transactions:*",
						IsArray: false,
					},
					Condition: map[string]interface{}{
						"NumericGreaterThanEquals": map[string]interface{}{
							"transaction.amount": 1000000,
						},
						"StringEquals": map[string]interface{}{
							"user.Role": "manager",
						},
					},
				},
			},
		},
		{
			ID:      "pol-003",
			Enabled: true,
			Statement: []models.PolicyStatement{
				{
					Sid:    "DenyExternalAccess",
					Effect: "Deny",
					Action: models.JSONActionResource{
						Single:  "*:*:*",
						IsArray: false,
					},
					Resource: models.JSONActionResource{
						Single:  "*",
						IsArray: false,
					},
					Condition: map[string]interface{}{
						"Bool": map[string]interface{}{
							"request.IsExternal": true,
						},
					},
				},
			},
		},
	}
}

func demoWildcardMatching() {
	actionMatcher := evaluator.NewActionMatcher()
	resourceMatcher := evaluator.NewResourceMatcher()

	// Action matching examples
	actionTests := []struct {
		pattern string
		action  string
	}{
		{"document-service:file:*", "document-service:file:read"},
		{"document-service:*:read", "document-service:file:read"},
		{"*:*:read", "payment-service:transaction:read"},
		{"*", "any:service:action"},
	}

	fmt.Println("Action Matching:")
	for _, test := range actionTests {
		result := actionMatcher.Match(test.pattern, test.action)
		fmt.Printf("  %s matches %s: %v\n", test.pattern, test.action, result)
	}

	// Resource matching examples
	context := map[string]interface{}{
		"request:UserId":  "user-123",
		"user:Department": "engineering",
	}

	resourceTests := []struct {
		pattern  string
		resource string
	}{
		{"api:documents:*", "api:documents:doc-123"},
		{"api:documents:owner:${request:UserId}/*", "api:documents:owner:user-123/file-1"},
		{"api:documents:dept:${user:Department}/*", "api:documents:dept:engineering/file-2"},
		{"*", "any:resource:here"},
	}

	fmt.Println("\nResource Matching:")
	for _, test := range resourceTests {
		result := resourceMatcher.Match(test.pattern, test.resource, context)
		fmt.Printf("  %s matches %s: %v\n", test.pattern, test.resource, result)
	}
}

func demoConditionEvaluation() {
	evaluator := evaluator.NewConditionEvaluator()

	context := map[string]interface{}{
		"user": map[string]interface{}{
			"department": "engineering",
			"level":      5,
			"mfa":        true,
		},
		"resource": map[string]interface{}{
			"sensitivity": "confidential",
		},
		"transaction": map[string]interface{}{
			"amount": 500000,
		},
		"request": map[string]interface{}{
			"sourceIp": "10.0.1.50",
		},
	}

	conditionTests := []struct {
		name       string
		conditions map[string]interface{}
	}{
		{
			name: "String Equals",
			conditions: map[string]interface{}{
				"StringEquals": map[string]interface{}{
					"user.department": "engineering",
				},
			},
		},
		{
			name: "Numeric Less Than",
			conditions: map[string]interface{}{
				"NumericLessThan": map[string]interface{}{
					"transaction.amount": 1000000,
				},
			},
		},
		{
			name: "Boolean Check",
			conditions: map[string]interface{}{
				"Bool": map[string]interface{}{
					"user.mfa": true,
				},
			},
		},
		{
			name: "IP Address Check",
			conditions: map[string]interface{}{
				"IpAddress": map[string]interface{}{
					"request.sourceIp": []interface{}{"10.0.0.0/8"},
				},
			},
		},
		{
			name: "Multiple Conditions (AND)",
			conditions: map[string]interface{}{
				"StringEquals": map[string]interface{}{
					"user.department": "engineering",
				},
				"Bool": map[string]interface{}{
					"user.mfa": true,
				},
			},
		},
	}

	for _, test := range conditionTests {
		result := evaluator.Evaluate(test.conditions, context)
		fmt.Printf("  %s: %v\n", test.name, result)

		// Pretty print the condition
		conditionJSON, _ := json.MarshalIndent(test.conditions, "    ", "  ")
		fmt.Printf("    Condition: %s\n", string(conditionJSON))
	}
}

// Helper function to evaluate new policies (for demo)
func evaluateNewPolicies(pdp *evaluator.PolicyDecisionPoint, policies []*models.Policy, context map[string]interface{}) *models.Decision {
	var matchedPolicies []string
	var matchedStatements []string

	// Step 1: Collect all matching statements
	for _, policy := range policies {
		if !policy.Enabled {
			continue
		}

		for _, statement := range policy.Statement {
			if evaluateStatement(pdp, statement, context) {
				matchedPolicies = append(matchedPolicies, policy.ID)
				if statement.Sid != "" {
					matchedStatements = append(matchedStatements, statement.Sid)
				}

				// Step 2: Apply Deny-Override - if any statement denies, return deny immediately
				if statement.Effect == "Deny" {
					return &models.Decision{
						Result:          "deny",
						MatchedPolicies: matchedPolicies,
						Reason:          fmt.Sprintf("Denied by statement: %s", statement.Sid),
					}
				}
			}
		}
	}

	// Step 3: If we have any Allow statements, return allow
	if len(matchedStatements) > 0 {
		return &models.Decision{
			Result:          "permit",
			MatchedPolicies: matchedPolicies,
			Reason:          fmt.Sprintf("Allowed by statements: %s", matchedStatements[0]),
		}
	}

	// Step 4: Default deny (no matching policies)
	return &models.Decision{
		Result:          "deny",
		MatchedPolicies: []string{},
		Reason:          "No matching policies found (implicit deny)",
	}
}

func evaluateStatement(pdp *evaluator.PolicyDecisionPoint, statement models.PolicyStatement, context map[string]interface{}) bool {
	// Step 1: Check action matching
	if !matchAction(pdp, statement.Action, context) {
		return false
	}

	// Step 2: Check resource matching
	if !matchResource(pdp, statement.Resource, context) {
		return false
	}

	// Step 3: Check conditions
	if len(statement.Condition) > 0 {
		// Create condition evaluator for this demo
		conditionEvaluator := evaluator.NewConditionEvaluator()
		expandedConditions := conditionEvaluator.SubstituteVariables(statement.Condition, context)
		if !conditionEvaluator.Evaluate(expandedConditions, context) {
			return false
		}
	}

	return true
}

func matchAction(pdp *evaluator.PolicyDecisionPoint, actionSpec models.JSONActionResource, context map[string]interface{}) bool {
	requestedAction, ok := context["request:Action"].(string)
	if !ok {
		return false
	}

	actionValues := actionSpec.GetValues()
	actionMatcher := evaluator.NewActionMatcher()
	for _, actionPattern := range actionValues {
		if actionMatcher.Match(actionPattern, requestedAction) {
			return true
		}
	}
	return false
}

func matchResource(pdp *evaluator.PolicyDecisionPoint, resourceSpec models.JSONActionResource, context map[string]interface{}) bool {
	requestedResource, ok := context["request:ResourceId"].(string)
	if !ok {
		return false
	}

	resourceValues := resourceSpec.GetValues()
	resourceMatcher := evaluator.NewResourceMatcher()
	for _, resourcePattern := range resourceValues {
		if resourceMatcher.Match(resourcePattern, requestedResource, context) {
			return true
		}
	}
	return false
}
